/***************************************************************************************
* Copyright (c) 2014-2022 Zihao Yu, Nanjing University
*
* NEMU is licensed under Mulan PSL v2.
* You can use this software according to the terms and conditions of the Mulan PSL v2.
* You may obtain a copy of Mulan PSL v2 at:
*          http://license.coscl.org.cn/MulanPSL2
*
* THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
* EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
* MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
*
* See the Mulan PSL v2 for more details.
***************************************************************************************/

#include "local-include/reg.h"
#include <cpu/cpu.h>
#include <cpu/ifetch.h>
#include <cpu/decode.h>

#define R(i) gpr(i)
#define Mr vaddr_read
#define Mw vaddr_write

enum {                                        //每种type的立即数位域相同
  TYPE_I, TYPE_U, TYPE_S, TYPE_J, TYPE_R, TYPE_B, 
  TYPE_N, // none
};

#define src1R() do { *src1 = R(rs1); } while (0)                      //将寄存器1的值赋给变量
#define src2R() do { *src2 = R(rs2); } while (0)
#define immI() do { *imm = SEXT(BITS(i, 31, 20), 12); } while(0)
#define immU() do { *imm = SEXT(BITS(i, 31, 12), 20) << 12; } while(0)
#define immS() do { *imm = (SEXT(BITS(i, 31, 25), 7) << 5) | BITS(i, 11, 7); } while(0)
/*
#define immS() do { 
  
*imm = 

(

  ({ 
    
  struct { int64_t n : 7; } __x = 
  { .n = (((i) >> (25)) & ((1ull << (31 - 25 + 1)) - 1)); 
  
  (uint64_t)__x.n; 
  
  })        //{}中包含一个复合语句块，返回最后一行
  
  
  << 5

) 

| (((i) >> (7)) & ((1ull << (11 - 7 + 1)) - 1)); 

} while(0)

*/

#define immJ() do \
{ *imm = (SEXT(BITS(i, 31, 31), 1) << 20) | BITS(i, 19, 12) << 12 | BITS(i, 20, 20) << 11 | BITS(i, 30, 21) << 1; } \
while(0)
#define immB() do \
{ *imm = (SEXT(BITS(i, 31, 31), 1) << 12) | BITS(i, 7, 7) << 11 | BITS(i, 30, 25) << 6 | BITS(i, 11, 8) << 1; } \
while(0)

static void decode_operand(Decode *s, int *rd, word_t *src1, word_t *src2, word_t *imm, int* shamt, int type) {  //为src1、src2、rd、imm等赋值
  uint32_t i = s->isa.inst.val;
  int rs1 = BITS(i, 19, 15);
  int rs2 = BITS(i, 24, 20);
  *rd     = BITS(i, 11, 7);
  *shamt  = BITS(i, 31, 26);
  switch (type) {
    case TYPE_I: src1R();          immI(); break;       //获取寄存器1的值，获取扩展的imm值
    case TYPE_U:                   immU(); break;
    case TYPE_S: src1R(); src2R(); immS(); break;
    case TYPE_J: src1R();          immJ(); break;
    case TYPE_R: src1R(); src2R();         break;
    case TYPE_B: src1R(); src2R(); immB(); break;
    case TYPE_N:                           break;
  }
}

static int decode_exec(Decode *s) {
  int rd = 0;
  int shamt = 0;
  word_t src1 = 0, src2 = 0, imm = 0;     //无符号
  s->dnpc = s->snpc;

#define INSTPAT_INST(s) ((s)->isa.inst.val)          
#define INSTPAT_MATCH(s, name, type, ... /* execute body */ ) { \
  decode_operand(s, &rd, &src1, &src2, &imm, &shamt, concat(TYPE_, type)); \
  __VA_ARGS__ ; \
}
//取inst
//
//获取源操作数、目的寄存器
//留下例如R(rd) = s->pc + imm)，执行指令操作




  //s->isa.inst.val依次匹配INSTPAT中的字符串，如果匹配成功
  //word_t函数读出的是无符号扩展，而lb是符号扩展

  INSTPAT_START();
  INSTPAT("???????????????????? ????? 0010111", auipc  , U, R(rd) = s->pc + imm);
  INSTPAT("???????????????????? ????? 0110111", lui  , U, R(rd) = imm);
  INSTPAT("? ?????????? ? ???????? ????? 11011 11", jal  , J, R(rd) = s->pc + 4; s->dnpc = (sword_t)(s->pc) + (sword_t)imm);
  INSTPAT("???????????? ????? 000 ????? 11001 11", jalr  , I, R(rd) = s->pc + 4; s->dnpc = ((sword_t)src1 + (sword_t)imm) & ~1);
  
  INSTPAT("??????? ????? ????? 000 ????? 1100011", beq  , B, if(src1 == src2)s->dnpc = (sword_t)(s->pc) + (sword_t)imm);
  INSTPAT("??????? ????? ????? 001 ????? 1100011", bne  , B, if(src1 != src2)s->dnpc = (sword_t)(s->pc) + (sword_t)imm);
  INSTPAT("??????? ????? ????? 100 ????? 1100011", blt  , B, if((sword_t)src1 < (sword_t)src2)s->dnpc = (sword_t)(s->pc) + (sword_t)imm);
  INSTPAT("??????? ????? ????? 101 ????? 1100011", bge  , B, if((sword_t)src1 > (sword_t)src2)s->dnpc = (sword_t)(s->pc) + (sword_t)imm);
  INSTPAT("??????? ????? ????? 110 ????? 1100011", bltu  , B, if(src1 < src2)s->dnpc = (sword_t)(s->pc) + (sword_t)imm);
  INSTPAT("??????? ????? ????? 111 ????? 1100011", bgeu  , B, if(src1 > src2)s->dnpc = (sword_t)(s->pc) + (sword_t)imm);

  INSTPAT("???????????? ????? 000 ????? 0000011", lb  , I,  R(rd) = SEXT(Mr(src1 + imm, 1), 8));       
  INSTPAT("???????????? ????? 001 ????? 0000011", lh  , I,  R(rd) = SEXT(Mr(src1 + imm, 2), 16));
  INSTPAT("???????????? ????? 010 ????? 0000011", lw  , I,  R(rd) = SEXT(Mr(src1 + imm, 4), 32));
  INSTPAT("???????????? ????? 100 ????? 0000011", lbu  , I, R(rd) = Mr(src1 + imm, 1));   
  INSTPAT("???????????? ????? 101 ????? 0000011", lhu  , I, R(rd) = Mr(src1 + imm, 2));
  INSTPAT("???????????? ????? 110 ????? 0000011", lwu  , I, R(rd) = Mr(src1 + imm, 4));
  INSTPAT("??????? ????? ????? 011 ????? 00000 11", ld , I, R(rd) = Mr(src1 + imm, 8));

  INSTPAT("??????? ????? ????? 000 ????? 0100011", sb , S, Mw(src1 + imm, 1, src2));             //需要存储的数据是不做符号扩展的,看指令描述
  INSTPAT("??????? ????? ????? 001 ????? 0100011", sh , S, Mw(src1 + imm, 2, src2));
  INSTPAT("??????? ????? ????? 010 ????? 0100011", sw , S, Mw(src1 + imm, 4, src2));
  INSTPAT("??????? ????? ????? 011 ????? 0100011", sd , S, Mw(src1 + imm, 8, src2));

  INSTPAT("???????????? ????? 000 ????? 0010011", addi  , I, R(rd) = (sword_t)src1 + (sword_t)imm);
  INSTPAT("???????????? ????? 010 ????? 0010011", slti  , I, R(rd) = ((sword_t)src1 < (sword_t)imm) ? 1 : 0);
  INSTPAT("???????????? ????? 011 ????? 0010011", sltiu  , I, R(rd) = (src1 < imm) ? 1 : 0);
  INSTPAT("???????????? ????? 100 ????? 0010011", xori  , I, R(rd) = src1 ^ imm);
  INSTPAT("???????????? ????? 110 ????? 0010011", ori  , I, R(rd) = src1 | imm);
  INSTPAT("???????????? ????? 111 ????? 0010011", andi  , I, R(rd) = src1 & imm);

  INSTPAT("0000000 ????? ????? 001 ????? 0010011", slli  , I, R(rd) = src1 << shamt);
  INSTPAT("0000000 ????? ????? 101 ????? 0010011", srli  , I, R(rd) = src1 >> shamt);
  INSTPAT("0100000 ????? ????? 101 ????? 0010011", srai  , I, R(rd) = (sword_t)src1 >> shamt);  //有符号数右移是算术

  INSTPAT("0000000 ????? ????? 000 ????? 0110011", add  , R, R(rd) = (sword_t)src1 + (sword_t)src2);
  INSTPAT("0100000 ????? ????? 000 ????? 0110011", sub  , R, R(rd) = (sword_t)src1 - (sword_t)src2);
  INSTPAT("0000000 ????? ????? 001 ????? 0110011", sll  , R, R(rd) = src1 << BITS(src2,5,0));
  INSTPAT("0000000 ????? ????? 010 ????? 0110011", slt  , R, R(rd) = ((sword_t)src1 < (sword_t)src2) ? 1 : 0);
  INSTPAT("0000000 ????? ????? 011 ????? 0110011", sltu  , R, R(rd) = src1 < src2 ? 1 : 0);
  INSTPAT("0000000 ????? ????? 100 ????? 0110011", xor  , R, R(rd) = src1 ^ src2);
  INSTPAT("0000000 ????? ????? 101 ????? 0110011", srl  , R, R(rd) = src1 >> BITS(src2,5,0));
  INSTPAT("0100000 ????? ????? 101 ????? 0110011", sra  , R, R(rd) = (sword_t)src1 >> BITS(src2,5,0));
  INSTPAT("0000000 ????? ????? 110 ????? 0110011", or  , R, R(rd) = src1 | src2);
  INSTPAT("0000000 ????? ????? 111 ????? 0110011", and  , R, R(rd) = src1 & src2);


  INSTPAT("???????????? ????? 000 ????? 0011011", addiw  , I, R(rd) = SEXT(BITS((sword_t)src1 + (sword_t)imm,31,0), 32));
  INSTPAT("0000000 ????? ????? 001 ????? 0011011", slliw  , I, R(rd) = SEXT(BITS(src1 << shamt,31,0), 32));
  INSTPAT("0000000 ????? ????? 101 ????? 0011011", srliw  , I, R(rd) = SEXT(BITS(src1 >> shamt,31,0), 32));
  INSTPAT("0100000 ????? ????? 101 ????? 0011011", sraiw  , I, R(rd) = SEXT(BITS((sword_t)src1 >> shamt,31,0), 32));

  INSTPAT("0000000 ????? ????? 000 ????? 0111011", addw  , R, R(rd) = SEXT(BITS((sword_t)src1 + (sword_t)src2,31,0), 32));
  INSTPAT("0100000 ????? ????? 000 ????? 0111011", subw  , R, R(rd) = SEXT(BITS((sword_t)src1 - (sword_t)src2,31,0), 32));
  INSTPAT("0000000 ????? ????? 001 ????? 0111011", sllw  , R, R(rd) = SEXT(BITS(src1 << src2,31,0), 32));
  INSTPAT("0000000 ????? ????? 101 ????? 0111011", srlw  , R, R(rd) = SEXT(BITS(src1 >> src2,31,0), 32));
  INSTPAT("0100000 ????? ????? 101 ????? 0111011", sraw  , R, R(rd) = SEXT(BITS((sword_t)src1 >> src2,31,0), 32));


  INSTPAT("0000000 00001 00000 000 00000 11100 11", ebreak , N, NEMUTRAP(s->pc, R(10))); 
  INSTPAT("??????? ????? ????? ??? ????? ????? ??", inv    , N, INV(s->pc));             
  INSTPAT_END();

  R(0) = 0; // reset $zero to 0

  return 0;
}

int isa_exec_once(Decode *s) {
  s->isa.inst.val = inst_fetch(&s->snpc, 4);          //获取指令并更新snpc
  return decode_exec(s);                            //译码并执行指令操作
}
