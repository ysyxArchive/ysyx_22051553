// Generated by CIRCT unknown git version
// Standard header to adapt well known macros to our needs.
`ifdef RANDOMIZE_REG_INIT
  `define RANDOMIZE
`endif // RANDOMIZE_REG_INIT

// RANDOM may be set to an expression that produces a 32-bit random unsigned value.
`ifndef RANDOM
  `define RANDOM $random
`endif // not def RANDOM

// Users can define 'PRINTF_COND' to add an extra gate to prints.
`ifdef PRINTF_COND
  `define PRINTF_COND_ (`PRINTF_COND)
`else  // PRINTF_COND
  `define PRINTF_COND_ 1
`endif // PRINTF_COND

// Users can define INIT_RANDOM as general code that gets injected into the
// initializer block for modules with registers.
`ifndef INIT_RANDOM
  `define INIT_RANDOM
`endif // not def INIT_RANDOM

// If using random initialization, you can also define RANDOMIZE_DELAY to
// customize the delay used, otherwise 0.002 is used.
`ifndef RANDOMIZE_DELAY
  `define RANDOMIZE_DELAY 0.002
`endif // not def RANDOMIZE_DELAY

// Define INIT_RANDOM_PROLOG_ for use in our modules below.
`ifdef RANDOMIZE
  `ifdef VERILATOR
    `define INIT_RANDOM_PROLOG_ `INIT_RANDOM
  `else  // VERILATOR
    `define INIT_RANDOM_PROLOG_ `INIT_RANDOM #`RANDOMIZE_DELAY begin end
  `endif // VERILATOR
`else  // RANDOMIZE
  `define INIT_RANDOM_PROLOG_
`endif // RANDOMIZE

module Button(	// <stdin>:2:10
  input        clock,
               reset,
               io_ps2_clk,
               io_ps2_data,
  output [3:0] io_button_out);

  reg  [9:0] buffer;	// Button.scala:55:36
  reg  [3:0] count;	// Button.scala:56:36
  reg  [2:0] ps2_clk_sync;	// Button.scala:57:36
  wire       sampling = ps2_clk_sync[2] & ~(ps2_clk_sync[1]);	// Button.scala:57:36, :60:{45,49,51,64}
  wire       _T_1 = count == 4'hA;	// Button.scala:56:36, :73:20
  wire [7:0] _io_button_out_T_61 = buffer[8:1] == 8'h1D ? 8'h1D : buffer[8:1] == 8'h22 ? 8'h22 : buffer[8:1] == 8'h35 ? 8'h35
                : buffer[8:1] == 8'h1A ? 8'h1A : buffer[8:1] == 8'hF0 ? 8'hF0 : 8'hFF;	// Button.scala:55:36, :70:19, :84:36, :106:42, :107:42, :108:42, :109:42, :111:42, Mux.scala:101:16
  always @(posedge clock) begin
    if (reset) begin
      buffer <= 10'h0;	// Button.scala:55:36
      count <= 4'h0;	// Button.scala:56:36
      ps2_clk_sync <= 3'h0;	// Button.scala:57:36
    end
    else begin
      if (~sampling | _T_1) begin	// Button.scala:55:36, :60:49, :72:30, :73:{20,29}
      end
      else	// Button.scala:55:36, :60:49, :72:30, :73:{20,29}
        buffer <= {count == 4'h9 ? io_ps2_data : buffer[9], count == 4'h8 ? io_ps2_data : buffer[8], count ==
                                                                4'h7 ? io_ps2_data : buffer[7], count == 4'h6 ? io_ps2_data : buffer[6], count == 4'h5 ?
                                                                io_ps2_data : buffer[5], count == 4'h4 ? io_ps2_data : buffer[4], count == 4'h3 ?
                                                                io_ps2_data : buffer[3], count == 4'h2 ? io_ps2_data : buffer[2], count == 4'h1 ?
                                                                io_ps2_data : buffer[1], count == 4'h0 ? io_ps2_data : buffer[0]};	// Button.scala:55:36, :56:36, :62:{36,44}, :64:22, :121:33
      if (sampling) begin	// Button.scala:60:49
        if (_T_1)	// Button.scala:73:20
          count <= 4'h0;	// Button.scala:56:36
        else	// Button.scala:73:20
          count <= count + 4'h1;	// Button.scala:56:36, :64:22, :123:28
      end
      ps2_clk_sync <= {ps2_clk_sync[1:0], io_ps2_clk};	// Button.scala:57:36, :67:37, Cat.scala:33:92
    end
  end // always @(posedge)
  `ifndef SYNTHESIS	// <stdin>:2:10
    `ifdef FIRRTL_BEFORE_INITIAL	// <stdin>:2:10
      `FIRRTL_BEFORE_INITIAL	// <stdin>:2:10
    `endif // FIRRTL_BEFORE_INITIAL
    initial begin	// <stdin>:2:10
      automatic logic [31:0] _RANDOM_0;	// <stdin>:2:10
      `ifdef INIT_RANDOM_PROLOG_	// <stdin>:2:10
        `INIT_RANDOM_PROLOG_	// <stdin>:2:10
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT	// <stdin>:2:10
        _RANDOM_0 = `RANDOM;	// <stdin>:2:10
        buffer = _RANDOM_0[9:0];	// Button.scala:55:36
        count = _RANDOM_0[13:10];	// Button.scala:55:36, :56:36
        ps2_clk_sync = _RANDOM_0[16:14];	// Button.scala:55:36, :57:36
      `endif // RANDOMIZE_REG_INIT
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL	// <stdin>:2:10
      `FIRRTL_AFTER_INITIAL	// <stdin>:2:10
    `endif // FIRRTL_AFTER_INITIAL
  `endif // not def SYNTHESIS
  assign io_button_out = sampling & _T_1 & ~(buffer[0]) & io_ps2_data & ^(buffer[9:1]) ? (buffer[8:1] == 8'h1C ?
                4'hC : buffer[8:1] == 8'h32 ? 4'h2 : buffer[8:1] == 8'h21 ? 4'h1 : buffer[8:1] == 8'h23 ?
                4'h3 : buffer[8:1] == 8'h24 ? 4'h4 : buffer[8:1] == 8'h2B ? 4'hB : buffer[8:1] == 8'h34 ?
                4'h4 : buffer[8:1] == 8'h33 | buffer[8:1] == 8'h43 ? 4'h3 : buffer[8:1] == 8'h3B ? 4'hB :
                buffer[8:1] == 8'h42 ? 4'h2 : buffer[8:1] == 8'h4B ? 4'hB : buffer[8:1] == 8'h3A ? 4'hA :
                buffer[8:1] == 8'h31 ? 4'h1 : buffer[8:1] == 8'h44 ? 4'h4 : buffer[8:1] == 8'h4D ? 4'hD :
                buffer[8:1] == 8'h15 ? 4'h5 : buffer[8:1] == 8'h2D ? 4'hD : buffer[8:1] == 8'h1B ? 4'hB :
                buffer[8:1] == 8'h2C | buffer[8:1] == 8'h3C ? 4'hC : buffer[8:1] == 8'h2A ? 4'hA :
                _io_button_out_T_61[3:0]) : 4'hF;	// <stdin>:2:10, Button.scala:55:36, :60:49, :62:44, :64:22, :70:19, :72:30, :73:{20,29}, :75:27, :77:{27,33}, :84:{36,42}, :85:42, :86:42, :87:42, :88:42, :89:42, :90:42, :91:42, :92:42, :93:42, :94:42, :95:42, :96:42, :97:42, :98:42, :99:42, :100:42, :101:42, :102:42, :103:42, :104:42, :105:42, Mux.scala:101:16
endmodule

module ButtonControl(	// <stdin>:157:10
  input        clock,
               reset,
  input  [3:0] io_validButton,
  output [7:0] io_count,
               io_code,
               io_ASCIIO,
  output       io_blank);

  reg        state;	// ButtonControl.scala:55:24
  reg  [7:0] count;	// ButtonControl.scala:57:24
  reg  [7:0] code;	// ButtonControl.scala:58:24
  reg  [7:0] ASCII;	// ButtonControl.scala:59:24
  reg        blank;	// ButtonControl.scala:61:24
  reg        waiton;	// ButtonControl.scala:63:25
  wire [7:0] _GEN = {4'h0, io_validButton};	// ButtonControl.scala:72:33
  wire       _T_11 = waiton & _GEN == code;	// ButtonControl.scala:58:24, :63:25, :72:33, :125:{25,43}
  always @(posedge clock) begin
    if (reset) begin
      state <= 1'h0;	// ButtonControl.scala:55:24
      count <= 8'h0;	// ButtonControl.scala:57:24
      code <= 8'hFF;	// ButtonControl.scala:58:24
      ASCII <= 8'hFF;	// ButtonControl.scala:58:24, :59:24
      blank <= 1'h0;	// ButtonControl.scala:55:24, :61:24
      waiton <= 1'h0;	// ButtonControl.scala:55:24, :63:25
    end
    else begin
      automatic logic _GEN_0;	// ButtonControl.scala:63:25, :66:19
      automatic logic _GEN_1;	// ButtonControl.scala:59:24, :66:19, :125:52
      _GEN_0 = ~state | ~_T_11;	// ButtonControl.scala:55:24, :63:25, :66:19, :121:48, :125:{25,52}, :126:24
      _GEN_1 = state & _T_11;	// ButtonControl.scala:55:24, :59:24, :66:19, :125:{25,52}
      state <= ~state | _GEN_0 & state;	// ButtonControl.scala:55:24, :63:25, :66:19, :72:82, :125:52
      if (state) begin	// ButtonControl.scala:55:24
        if (_GEN_1)	// ButtonControl.scala:59:24, :66:19, :125:52
          code <= 8'hFF;	// ButtonControl.scala:58:24
      end
      else begin	// ButtonControl.scala:55:24
        count <= count + 8'h1;	// ButtonControl.scala:57:24, :79:32
        code <= _GEN;	// ButtonControl.scala:58:24, :72:33
      end
      if (~state | _GEN_1)	// ButtonControl.scala:55:24, :59:24, :63:25, :66:19, :72:82, :125:52
        ASCII <= 8'hFF;	// ButtonControl.scala:58:24, :59:24
      blank <= state & (_GEN_1 | blank);	// ButtonControl.scala:55:24, :59:24, :61:24, :66:19, :72:82, :125:52
      waiton <= _GEN_0 & waiton;	// ButtonControl.scala:63:25, :66:19
    end
  end // always @(posedge)
  `ifndef SYNTHESIS	// <stdin>:157:10
    always @(posedge clock) begin	// ButtonControl.scala:69:19
      if ((`PRINTF_COND_) & ~state & ~reset)	// ButtonControl.scala:55:24, :66:19, :69:19
        $fwrite(32'h80000002, "button is %x", io_validButton);	// ButtonControl.scala:69:19
      if ((`PRINTF_COND_) & ~state & ~reset)	// ButtonControl.scala:55:24, :66:19, :69:19, :77:23
        $fwrite(32'h80000002, "code is %x", code);	// ButtonControl.scala:58:24, :69:19, :77:23
      if ((`PRINTF_COND_) & state & _T_11 & ~reset)	// ButtonControl.scala:55:24, :69:19, :125:25, :132:23
        $fwrite(32'h80000002, "code = %x", ASCII);	// ButtonControl.scala:59:24, :69:19, :132:23
    end // always @(posedge)
    `ifdef FIRRTL_BEFORE_INITIAL	// <stdin>:157:10
      `FIRRTL_BEFORE_INITIAL	// <stdin>:157:10
    `endif // FIRRTL_BEFORE_INITIAL
    initial begin	// <stdin>:157:10
      automatic logic [31:0] _RANDOM_0;	// <stdin>:157:10
      `ifdef INIT_RANDOM_PROLOG_	// <stdin>:157:10
        `INIT_RANDOM_PROLOG_	// <stdin>:157:10
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT	// <stdin>:157:10
        _RANDOM_0 = `RANDOM;	// <stdin>:157:10
        state = _RANDOM_0[0];	// ButtonControl.scala:55:24
        count = _RANDOM_0[8:1];	// ButtonControl.scala:55:24, :57:24
        code = _RANDOM_0[16:9];	// ButtonControl.scala:55:24, :58:24
        ASCII = _RANDOM_0[24:17];	// ButtonControl.scala:55:24, :59:24
        blank = _RANDOM_0[25];	// ButtonControl.scala:55:24, :61:24
        waiton = _RANDOM_0[26];	// ButtonControl.scala:55:24, :63:25
      `endif // RANDOMIZE_REG_INIT
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL	// <stdin>:157:10
      `FIRRTL_AFTER_INITIAL	// <stdin>:157:10
    `endif // FIRRTL_AFTER_INITIAL
  `endif // not def SYNTHESIS
  assign io_count = count;	// <stdin>:157:10, ButtonControl.scala:57:24
  assign io_code = code;	// <stdin>:157:10, ButtonControl.scala:58:24
  assign io_ASCIIO = ASCII;	// <stdin>:157:10, ButtonControl.scala:59:24
  assign io_blank = blank;	// <stdin>:157:10, ButtonControl.scala:61:24
endmodule

module Seg(	// <stdin>:270:10
  input        io_blank,
  input  [3:0] io_dataIn_0,
               io_dataIn_1,
               io_dataIn_2,
               io_dataIn_3,
               io_dataIn_4,
               io_dataIn_5,
  output [6:0] io_encodeOut_0,
               io_encodeOut_1,
               io_encodeOut_2,
               io_encodeOut_3,
               io_encodeOut_4,
               io_encodeOut_5);

  wire [15:0][6:0] _GEN = {{7'h38}, {7'h30}, {7'h42}, {7'h31}, {7'h60}, {7'h8}, {7'h4}, {7'h0}, {7'hF}, {7'h20},
                {7'h24}, {7'h4C}, {7'h6}, {7'h12}, {7'h4F}, {7'h1}};	// Mux.scala:81:{58,61}
  assign io_encodeOut_0 = io_blank ? 7'h7F : _GEN[io_dataIn_0];	// <stdin>:270:10, Mux.scala:81:{58,61}, Seg.scala:37:30, :38:25, :40:25
  assign io_encodeOut_1 = io_blank ? 7'h7F : _GEN[io_dataIn_1];	// <stdin>:270:10, Mux.scala:81:{58,61}, Seg.scala:38:25, :42:30, :43:25, :45:25
  assign io_encodeOut_2 = io_blank ? 7'h7F : _GEN[io_dataIn_2];	// <stdin>:270:10, Mux.scala:81:{58,61}, Seg.scala:38:25, :47:30, :48:25, :50:25
  assign io_encodeOut_3 = io_blank ? 7'h7F : _GEN[io_dataIn_3];	// <stdin>:270:10, Mux.scala:81:{58,61}, Seg.scala:38:25, :52:30, :53:25, :55:25
  assign io_encodeOut_4 = _GEN[io_dataIn_4];	// <stdin>:270:10, Mux.scala:81:{58,61}
  assign io_encodeOut_5 = _GEN[io_dataIn_5];	// <stdin>:270:10, Mux.scala:81:{58,61}
endmodule

module top(	// <stdin>:478:10
  input        clock,
               reset,
               io_ps2_clk,
               io_ps2_data,
  output [6:0] io_seg5,
               io_seg4,
               io_seg3,
               io_seg2,
               io_seg1,
               io_seg0);

  wire [7:0] _ButtonControl_io_count;	// top.scala:24:31
  wire [7:0] _ButtonControl_io_code;	// top.scala:24:31
  wire [7:0] _ButtonControl_io_ASCIIO;	// top.scala:24:31
  wire       _ButtonControl_io_blank;	// top.scala:24:31
  wire [3:0] _Button_io_button_out;	// top.scala:19:24
  Button Button (	// top.scala:19:24
    .clock         (clock),
    .reset         (reset),
    .io_ps2_clk    (io_ps2_clk),
    .io_ps2_data   (io_ps2_data),
    .io_button_out (_Button_io_button_out)
  );
  ButtonControl ButtonControl (	// top.scala:24:31
    .clock          (clock),
    .reset          (reset),
    .io_validButton (_Button_io_button_out),	// top.scala:19:24
    .io_count       (_ButtonControl_io_count),
    .io_code        (_ButtonControl_io_code),
    .io_ASCIIO      (_ButtonControl_io_ASCIIO),
    .io_blank       (_ButtonControl_io_blank)
  );
  Seg Seg (	// top.scala:28:21
    .io_blank       (_ButtonControl_io_blank),	// top.scala:24:31
    .io_dataIn_0    (_ButtonControl_io_code[3:0]),	// top.scala:24:31, :30:46
    .io_dataIn_1    (_ButtonControl_io_code[7:4]),	// top.scala:24:31, :31:46
    .io_dataIn_2    (_ButtonControl_io_ASCIIO[3:0]),	// top.scala:24:31, :32:48
    .io_dataIn_3    (_ButtonControl_io_ASCIIO[7:4]),	// top.scala:24:31, :33:48
    .io_dataIn_4    (_ButtonControl_io_count[3:0]),	// top.scala:24:31, :34:47
    .io_dataIn_5    (_ButtonControl_io_count[7:4]),	// top.scala:24:31, :35:47
    .io_encodeOut_0 (io_seg0),
    .io_encodeOut_1 (io_seg1),
    .io_encodeOut_2 (io_seg2),
    .io_encodeOut_3 (io_seg3),
    .io_encodeOut_4 (io_seg4),
    .io_encodeOut_5 (io_seg5)
  );
endmodule

